#if VU_NEW_DB

#include "vucoll.h"

#else
// sfr: old implementation
//////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

#include "vu2.h"
#include "vu_priv.h"

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

//-----------------------------------------------------------------------------
// VuAntiDatabase
//-----------------------------------------------------------------------------

VuAntiDatabase::VuAntiDatabase(uint tableSize, uint key) : VuHashTable(tableSize, key)
{
	// empty
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

VuAntiDatabase::~VuAntiDatabase()
{
	Purge();
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

int VuAntiDatabase::Purge (VU_BOOL all)
{
	int retval = 0;
	unsigned int index = 0;
	VuLinkNode **entry = table_;
	VuLinkNode *ptr = *entry;
	VuLinkNode *next, *last;
	
	VuEnterCriticalSection();

	while (index < capacity_){
		last = 0;
		while (ptr->entity_){
			next = ptr->next_;
			// sfr: smartpointer
			VuEntity *ent = ptr->entity_.get();

			if (!all && ((ent->IsPrivate()&&ent->IsPersistent()) || ent->IsGlobal())){
				ptr->next_ = vuTailNode;
				if (last){
					last->next_ = ptr;
				}
				else{
					*entry = ptr;
				}
				last = ptr;
			}
			else {
				vuCollectionManager->PutOnKillQueue(ptr, TRUE);
				//ptr->entity_.reset();
				// sfr: smartpointer
				//VuDeReferenceEntity(ent);
				retval++;
				count_--;
			}
			ptr = next;
		}

		if (!last){
			*entry = vuTailNode;
		}

		index++;
		entry = table_ + index;
		ptr = *entry;
	}

	VuExitCriticalSection();

	return retval;
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

VU_ERRCODE VuAntiDatabase::Insert (VuEntity *entity)
{
	if (vuDatabase->Find(entity->Id()) == 0)
	{
		VuEnterCriticalSection();

		// to ensure hash table insert succeeds
		entity->SetVuState(VU_MEM_ACTIVE);
		VuHashTable::Insert(entity);
		entity->SetVuState(VU_MEM_SUSPENDED);

		// sfr: smartpointer
		//VuReferenceEntity(entity);
		VuExitCriticalSection();

		return VU_SUCCESS;
	}
	return VU_NO_OP;
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

VU_ERRCODE VuAntiDatabase::Remove(VuEntity *entity)
{
	if (VuHashTable::Remove(entity)){
		if (vuDatabase->Find(entity->Id()) == 0){
			entity->SetVuState(VU_MEM_PENDING_DELETE);
		}
		// sfr: smartpointer
		//VuDeReferenceEntity(entity);
		return VU_SUCCESS;
	}
	return VU_NO_OP;
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

VU_ERRCODE VuAntiDatabase::Remove (VU_ID entityId)
{
	VuEntity *ent = Find(entityId);

	if (ent)
	{
		return Remove(ent);
	}

	return VU_NO_OP;
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

int VuAntiDatabase::Type()
{
	return VU_ANTI_DATABASE_COLLECTION;
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif
